/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of LetterTree.xs. Do not edit this file, edit LetterTree.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "LetterTree.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include "lettertree.h"

#line 19 "LetterTree.c"
XS(XS_Data__LetterTree_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Data__LetterTree_new)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Data::LetterTree::new(class)");
    {
	char *	class = (char *)SvPV_nolen(ST(0));
	Node *	RETVAL;
#line 15 "LetterTree.xs"
	RETVAL = new_tree();
#line 31 "LetterTree.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "NodePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_NodePtr_add_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_NodePtr_add_data)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: NodePtr::add_data(tree, word, data)");
    {
	Node *	tree;
	char *	word = (char *)SvPV_nolen(ST(1));
	SV *	data = ST(2);
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "NodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    tree = INT2PTR(Node *,tmp);
	}
	else
	    Perl_croak(aTHX_ "tree is not of type NodePtr");

	RETVAL = add_data(tree, word, data);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_NodePtr_has_word); /* prototype to pass -Wmissing-prototypes */
XS(XS_NodePtr_has_word)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NodePtr::has_word(tree, word)");
    {
	Node *	tree;
	char *	word = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "NodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    tree = INT2PTR(Node *,tmp);
	}
	else
	    Perl_croak(aTHX_ "tree is not of type NodePtr");

	RETVAL = has_word(tree, word);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_NodePtr_parse_tree); /* prototype to pass -Wmissing-prototypes */
XS(XS_NodePtr_parse_tree)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NodePtr::parse_tree(tree)");
    {
	Node *	tree;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "NodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    tree = INT2PTR(Node *,tmp);
	}
	else
	    Perl_croak(aTHX_ "tree is not of type NodePtr");

	RETVAL = parse_tree(tree);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_NodePtr_get_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_NodePtr_get_data)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NodePtr::get_data(tree, word)");
    SP -= items;
    {
	Node *	tree;
	char *	word = (char *)SvPV_nolen(ST(1));
#line 41 "LetterTree.xs"
	SV** data;
	int i = 0;
#line 126 "LetterTree.c"

	if (sv_derived_from(ST(0), "NodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    tree = INT2PTR(Node *,tmp);
	}
	else
	    Perl_croak(aTHX_ "tree is not of type NodePtr");
#line 44 "LetterTree.xs"
	data = get_data(tree, word);
	if (data) 
	    while (data[i]) 
		XPUSHs((SV*) data[i++]);
#line 139 "LetterTree.c"
	PUTBACK;
	return;
    }
}

XS(XS_NodePtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_NodePtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NodePtr::DESTROY(tree)");
    {
	Node *	tree;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    tree = INT2PTR(Node *,tmp);
	}
	else
	    Perl_croak(aTHX_ "tree is not a reference");
#line 53 "LetterTree.xs"
	delete_tree(tree);
#line 162 "LetterTree.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Data__LetterTree); /* prototype to pass -Wmissing-prototypes */
XS(boot_Data__LetterTree)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("Data::LetterTree::new", XS_Data__LetterTree_new, file);
        newXS("NodePtr::add_data", XS_NodePtr_add_data, file);
        newXS("NodePtr::has_word", XS_NodePtr_has_word, file);
        newXS("NodePtr::parse_tree", XS_NodePtr_parse_tree, file);
        newXS("NodePtr::get_data", XS_NodePtr_get_data, file);
        newXS("NodePtr::DESTROY", XS_NodePtr_DESTROY, file);
    XSRETURN_YES;
}

